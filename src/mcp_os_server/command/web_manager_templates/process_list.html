<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Command Server - è¿›ç¨‹ç®¡ç†</title>
    <style>
        /* === åŸºç¡€æ ·å¼ === */
        :root {
            --primary-color: #007bff;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #fd7e14;
            --secondary-color: #6c757d;
            --light-bg: #f8f9fa;
            --border-color: #e0e0e0;
            --hover-bg: #e3f2fd;
            --text-primary: #333;
            --text-secondary: #7f8c8d;
            --shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: var(--text-primary);
        }

        /* === å¸ƒå±€å®¹å™¨ === */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: var(--shadow);
        }

        /* === å¤´éƒ¨æ ·å¼ === */
        .header {
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header .subtitle {
            color: var(--text-secondary);
            margin-bottom: 0;
        }

        /* === ç­›é€‰å™¨æ ·å¼ === */
        .filters {
            margin-bottom: 20px;
            padding: 20px;
            background-color: var(--light-bg);
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .filters h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #495057;
        }

        .filter-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-group label {
            font-weight: 500;
            white-space: nowrap;
        }

        /* === è¡¨å•æ§ä»¶æ ·å¼ === */
        select, input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        /* === æŒ‰é’®æ ·å¼ === */
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-decoration: none;
            display: inline-block;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover { background-color: #0056b3; }

        .btn-success { background-color: var(--success-color); color: white; }
        .btn-success:hover { background-color: #218838; }

        .btn-danger { background-color: var(--danger-color); color: white; }
        .btn-danger:hover { background-color: #c82333; }

        .btn-secondary { background-color: var(--secondary-color); color: white; }
        .btn-secondary:hover { background-color: #545b62; }

        /* === è¡¨æ ¼æ ·å¼ === */
        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background-color: #fff;
            min-width: 800px;
        }

        th, td {
            padding: 12px 8px;
            border: 1px solid var(--border-color);
            text-align: left;
            font-size: 14px;
        }

        th {
            background-color: var(--light-bg);
            font-weight: 600;
            color: #495057;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        tbody tr:nth-child(even) {
            background-color: var(--light-bg);
        }

        tbody tr:hover {
            background-color: var(--hover-bg);
        }

        /* === çŠ¶æ€æ ·å¼ === */
        .status {
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }

        .status-running { color: var(--success-color); background-color: rgba(40, 167, 69, 0.1); }
        .status-completed { color: var(--primary-color); background-color: rgba(0, 123, 255, 0.1); }
        .status-failed, .status-error { color: var(--danger-color); background-color: rgba(220, 53, 69, 0.1); }
        .status-terminated { color: var(--warning-color); background-color: rgba(253, 126, 20, 0.1); }

        /* === æ“ä½œæŒ‰é’®ç»„ === */
        .actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        /* === åˆ—å®½æ§åˆ¶ === */
        .col-pid { width: 80px; }
        .col-command { max-width: 200px; word-break: break-all; }
        .col-description { max-width: 150px; word-break: break-word; }
        .col-status { width: 80px; }
        .col-time { width: 140px; }
        .col-actions { width: 180px; }

        /* === çŠ¶æ€å’Œæ¶ˆæ¯æ ·å¼ === */
        .loading, .no-processes {
            text-align: center;
            padding: 40px;
            color: var(--secondary-color);
        }

        .no-processes {
            font-style: italic;
        }

        .error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            border-left: 4px solid var(--danger-color);
        }

        /* === å“åº”å¼è®¾è®¡ === */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .filter-row {
                flex-direction: column;
                align-items: stretch;
            }

            .filter-group {
                justify-content: space-between;
            }

            .actions {
                flex-direction: column;
            }

            .btn {
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- é¡µé¢å¤´éƒ¨ -->
        <header class="header">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h1 style="margin: 0;">MCP Command Server</h1>
                <div class="nav-links" style="display: flex; gap: 10px;">
                    <a href="/debug/threads" class="btn btn-primary" style="text-decoration: none;">ğŸ§µ çº¿ç¨‹è°ƒè¯•</a>
                    <a href="/debug/tasks" class="btn btn-primary" style="text-decoration: none;">âš¡ ä»»åŠ¡ç›‘æ§</a>
                </div>
            </div>
            <p class="subtitle">åå°è¿›ç¨‹ç®¡ç†ç•Œé¢</p>
        </header>
        
        <!-- ç­›é€‰å™¨åŒºåŸŸ -->
        <section class="filters">
            <h3>ç­›é€‰é€‰é¡¹</h3>
            <div class="filter-row">
                <div class="filter-group">
                    <label for="status">çŠ¶æ€ï¼š</label>
                    <select id="status" name="status">
                        <option value="">å…¨éƒ¨</option>
                        <option value="running">è¿è¡Œä¸­</option>
                        <option value="completed">å·²å®Œæˆ</option>
                        <option value="failed">å¤±è´¥</option>
                        <option value="terminated">å·²ç»ˆæ­¢</option>
                        <option value="error">é”™è¯¯</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="labels">æ ‡ç­¾ï¼š</label>
                    <input type="text" id="labels" name="labels" placeholder="ç”¨é€—å·åˆ†éš”å¤šä¸ªæ ‡ç­¾">
                </div>
                <button type="button" class="btn btn-primary" id="applyFilter">åº”ç”¨ç­›é€‰</button>
                <button type="button" class="btn btn-secondary" id="resetFilter">é‡ç½®</button>
                <button type="button" class="btn btn-success" id="refreshBtn">åˆ·æ–°</button>
            </div>
        </section>
        
        <!-- é”™è¯¯æ¶ˆæ¯åŒºåŸŸ -->
        <div id="errorMessage" class="error" style="display: none;"></div>
        
        <!-- è¿›ç¨‹è¡¨æ ¼ -->
        <section class="table-container">
            <table id="processTable">
                <thead>
                    <tr>
                        <th class="col-pid">è¿›ç¨‹ID</th>
                        <th class="col-command">å‘½ä»¤</th>
                        <th class="col-description">æè¿°</th>
                        <th class="col-status">çŠ¶æ€</th>
                        <th class="col-time">å¼€å§‹æ—¶é—´</th>
                        <th class="col-time">è¿è¡Œæ—¶é—´</th>
                        <th class="col-actions">æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody id="processTableBody">
                    <tr>
                        <td colspan="7" class="loading">æ­£åœ¨åŠ è½½è¿›ç¨‹åˆ—è¡¨...</td>
                    </tr>
                </tbody>
            </table>
        </section>
    </div>

    <!-- JavaScript ä»£ç  -->
    <script>
        /**
         * è¿›ç¨‹åˆ—è¡¨ç®¡ç†å™¨
         */
        class ProcessListManager {
            constructor() {
                this.currentFilters = { status: '', labels: '' };
                this.refreshInterval = null;
                this.autoRefreshEnabled = true;
                this.autoRefreshDelay = 5000; // 5ç§’è‡ªåŠ¨åˆ·æ–°
                
                this.initializeElements();
                this.bindEvents();
                this.loadProcesses();
                this.startAutoRefresh();
            }

            /**
             * åˆå§‹åŒ–DOMå…ƒç´ å¼•ç”¨
             */
            initializeElements() {
                this.elements = {
                    statusSelect: document.getElementById('status'),
                    labelsInput: document.getElementById('labels'),
                    applyFilterBtn: document.getElementById('applyFilter'),
                    resetFilterBtn: document.getElementById('resetFilter'),
                    refreshBtn: document.getElementById('refreshBtn'),
                    errorMessage: document.getElementById('errorMessage'),
                    processTableBody: document.getElementById('processTableBody')
                };
            }

            /**
             * ç»‘å®šäº‹ä»¶å¤„ç†å™¨
             */
            bindEvents() {
                this.elements.applyFilterBtn.addEventListener('click', () => this.applyFilters());
                this.elements.resetFilterBtn.addEventListener('click', () => this.resetFilters());
                this.elements.refreshBtn.addEventListener('click', () => this.loadProcesses());
                
                // å›è½¦é”®åº”ç”¨ç­›é€‰
                this.elements.labelsInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.applyFilters();
                });

                // é¡µé¢è·å¾—ç„¦ç‚¹æ—¶åˆ·æ–°
                window.addEventListener('focus', () => this.loadProcesses());
            }

            /**
             * å¯åŠ¨è‡ªåŠ¨åˆ·æ–°
             */
            startAutoRefresh() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
                
                if (this.autoRefreshEnabled) {
                    this.refreshInterval = setInterval(() => {
                        this.loadProcesses(true); // é™é»˜åˆ·æ–°
                    }, this.autoRefreshDelay);
                }
            }

            /**
             * åœæ­¢è‡ªåŠ¨åˆ·æ–°
             */
            stopAutoRefresh() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                    this.refreshInterval = null;
                }
            }

            /**
             * åº”ç”¨ç­›é€‰å™¨
             */
            applyFilters() {
                this.currentFilters = {
                    status: this.elements.statusSelect.value,
                    labels: this.elements.labelsInput.value
                };
                this.loadProcesses();
            }

            /**
             * é‡ç½®ç­›é€‰å™¨
             */
            resetFilters() {
                this.elements.statusSelect.value = '';
                this.elements.labelsInput.value = '';
                this.currentFilters = { status: '', labels: '' };
                this.loadProcesses();
            }

            /**
             * æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
             */
            showError(message) {
                this.elements.errorMessage.textContent = message;
                this.elements.errorMessage.style.display = 'block';
                setTimeout(() => {
                    this.elements.errorMessage.style.display = 'none';
                }, 5000);
            }

            /**
             * éšè—é”™è¯¯æ¶ˆæ¯
             */
            hideError() {
                this.elements.errorMessage.style.display = 'none';
            }

            /**
             * åŠ è½½è¿›ç¨‹åˆ—è¡¨
             */
            async loadProcesses(silent = false) {
                if (!silent) {
                    this.elements.processTableBody.innerHTML = '<tr><td colspan="7" class="loading">æ­£åœ¨åŠ è½½è¿›ç¨‹åˆ—è¡¨...</td></tr>';
                }
                
                this.hideError();

                try {
                    const params = new URLSearchParams();
                    if (this.currentFilters.status) params.append('status', this.currentFilters.status);
                    if (this.currentFilters.labels) params.append('labels', this.currentFilters.labels);

                    const response = await fetch(`/api/processes?${params.toString()}`);
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'è·å–è¿›ç¨‹åˆ—è¡¨å¤±è´¥');
                    }

                    this.renderProcessTable(data.data);
                } catch (error) {
                    console.error('Error loading processes:', error);
                    if (!silent) {
                        this.showError('åŠ è½½è¿›ç¨‹åˆ—è¡¨å¤±è´¥: ' + error.message);
                        this.elements.processTableBody.innerHTML = '<tr><td colspan="7" class="error">åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•</td></tr>';
                    }
                }
            }

            /**
             * æ¸²æŸ“è¿›ç¨‹è¡¨æ ¼
             */
            renderProcessTable(processes) {
                if (!processes || processes.length === 0) {
                    this.elements.processTableBody.innerHTML = '<tr><td colspan="7" class="no-processes">æš‚æ— è¿›ç¨‹</td></tr>';
                    return;
                }

                const rows = processes.map(process => this.createProcessRow(process)).join('');
                this.elements.processTableBody.innerHTML = rows;
            }

            /**
             * åˆ›å»ºè¿›ç¨‹è¡ŒHTML
             */
            createProcessRow(process) {
                const statusClass = `status status-${process.status}`;
                const startTime = process.start_time ? this.formatDateTime(process.start_time) : '-';
                const duration = this.formatDuration(process.duration);
                const command = this.truncateText(process.command.join(' '), 50);
                const description = this.truncateText(process.description, 30);

                return `
                    <tr data-pid="${process.pid}">
                        <td class="col-pid">${this.escapeHtml(process.pid)}</td>
                        <td class="col-command" title="${this.escapeHtml(process.command.join(' '))}">${this.escapeHtml(command)}</td>
                        <td class="col-description" title="${this.escapeHtml(process.description)}">${this.escapeHtml(description)}</td>
                        <td class="col-status"><span class="${statusClass}">${this.getStatusText(process.status)}</span></td>
                        <td class="col-time">${startTime}</td>
                        <td class="col-time">${duration}</td>
                        <td class="col-actions">
                            <div class="actions">
                                <a href="/process/${process.pid}" class="btn btn-success" title="æŸ¥çœ‹è¯¦æƒ…">æŸ¥çœ‹</a>
                                ${process.status === 'running' ? `<button class="btn btn-danger" onclick="processManager.stopProcess('${process.pid}')" title="åœæ­¢è¿›ç¨‹">åœæ­¢</button>` : ''}
                                ${['completed', 'failed', 'terminated', 'error'].includes(process.status) ? `<button class="btn btn-primary" onclick="processManager.cleanProcess('${process.pid}')" title="æ¸…ç†è¿›ç¨‹">æ¸…ç†</button>` : ''}
                            </div>
                        </td>
                    </tr>
                `;
            }

            /**
             * åœæ­¢è¿›ç¨‹
             */
            async stopProcess(pid) {
                if (!confirm(`ç¡®å®šè¦åœæ­¢è¿›ç¨‹ ${pid} å—ï¼Ÿ`)) return;

                try {
                    const response = await fetch(`/api/processes/${pid}/stop`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ force: false })
                    });

                    const data = await response.json();
                    if (!response.ok) {
                        throw new Error(data.error || 'åœæ­¢è¿›ç¨‹å¤±è´¥');
                    }

                    this.loadProcesses();
                } catch (error) {
                    console.error('Error stopping process:', error);
                    this.showError('åœæ­¢è¿›ç¨‹å¤±è´¥: ' + error.message);
                }
            }

            /**
             * æ¸…ç†è¿›ç¨‹
             */
            async cleanProcess(pid) {
                if (!confirm(`ç¡®å®šè¦æ¸…ç†è¿›ç¨‹ ${pid} å—ï¼Ÿ`)) return;

                try {
                    const response = await fetch(`/api/processes/${pid}/clean`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    const data = await response.json();
                    if (!response.ok) {
                        throw new Error(data.error || 'æ¸…ç†è¿›ç¨‹å¤±è´¥');
                    }

                    this.loadProcesses();
                } catch (error) {
                    console.error('Error cleaning process:', error);
                    this.showError('æ¸…ç†è¿›ç¨‹å¤±è´¥: ' + error.message);
                }
            }

            // === å·¥å…·æ–¹æ³• ===

            /**
             * æ ¼å¼åŒ–æ—¥æœŸæ—¶é—´
             */
            formatDateTime(isoString) {
                if (!isoString) return '-';
                try {
                    const date = new Date(isoString);
                    return date.toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                } catch {
                    return '-';
                }
            }

            /**
             * æ ¼å¼åŒ–æŒç»­æ—¶é—´
             */
            formatDuration(seconds) {
                if (!seconds || seconds < 0) return '-';
                
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                
                if (hours > 0) return `${hours}h ${minutes}m ${secs}s`;
                if (minutes > 0) return `${minutes}m ${secs}s`;
                return `${secs}s`;
            }

            /**
             * æˆªæ–­æ–‡æœ¬
             */
            truncateText(text, maxLength) {
                if (!text || text.length <= maxLength) return text;
                return text.substring(0, maxLength) + '...';
            }

            /**
             * è½¬ä¹‰HTML
             */
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            /**
             * è·å–çŠ¶æ€æ–‡æœ¬
             */
            getStatusText(status) {
                const statusMap = {
                    'running': 'è¿è¡Œä¸­',
                    'completed': 'å·²å®Œæˆ',
                    'failed': 'å¤±è´¥',
                    'terminated': 'å·²ç»ˆæ­¢',
                    'error': 'é”™è¯¯'
                };
                return statusMap[status] || status;
            }
        }

        // åˆå§‹åŒ–è¿›ç¨‹ç®¡ç†å™¨
        let processManager;
        document.addEventListener('DOMContentLoaded', () => {
            processManager = new ProcessListManager();
        });

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', () => {
            if (processManager) {
                processManager.stopAutoRefresh();
            }
        });
    </script>
</body>
</html> 